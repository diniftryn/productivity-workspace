{"ast":null,"code":"var _jsxFileName = \"/Users/dini/Desktop/productivity-workspace/frontend/src/components/SortableTaskList.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useRef, forwardRef } from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"./css/TaskList.css\";\n\n/**\n * Demo:\n * https://codepen.io/catamphetamine/pen/qBWxEQX\n *\n * `TaskListItem` receives properties:\n * `dragging: boolean` — Is `true` when some item is being dragged.\n * `dragged: boolean` — Is `true` when this item is being dragged.\n * `style: object` — The `style` that must be set on the item root element.\n */\nimport { createElement as _createElement } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction SortableTaskList({\n  value: items,\n  onChange,\n  component: Component,\n  taskListItem: TaskListItem,\n  taskListItemProps,\n  dragHandleDataAttribute,\n  animationDuration,\n  animationEasing,\n  ...rest\n}) {\n  _s();\n  const list = useRef();\n  const [dragging, setDragging] = useState();\n  const [willEndDragging, setWillEndDragging] = useState();\n  const touchId = useRef();\n  const dragMoveHandler = useRef();\n  const draggedItemPosition = useRef();\n  const itemShiftsY = useRef();\n  const itemsOrder = useRef();\n  const prevItems = useRef();\n  if (items !== prevItems.current) {\n    prevItems.current = items;\n    // Reset items order.\n    itemsOrder.current = items.map((item, i) => i);\n  }\n  const onDragStart = useCallback((node, y, touch) => {\n    if (dragging) {\n      return;\n    }\n    // The list requires at least two items in order to be sortable.\n    if (items.length === 1) {\n      return;\n    }\n    const item = getItem(list.current, node, dragHandleDataAttribute);\n    if (!item) {\n      return;\n    }\n    const [itemNode, position] = item;\n    setDragging({\n      touch,\n      initialPosition: position,\n      // Using `.getBoundingClientRect()` instead of `.offsetHeight`/`.offsetTop`\n      // because `.offsetXxx` values don't know how to work with fractional pixels.\n      // Fractional pixels (for example, `0.5`) are used on \"retina\" screens.\n      itemHeights: Array.prototype.map.call(list.current.childNodes, node => node.getBoundingClientRect().height),\n      itemSpacing: list.current.childNodes[1].getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().bottom,\n      itemTopOffset: itemNode.getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().top,\n      dragStartY: y\n    });\n    draggedItemPosition.current = {\n      previous: position,\n      new: position,\n      shiftY: 0\n    };\n    itemShiftsY.current = items.map(_ => 0);\n  }, [dragging]);\n  const onMouseDown = useCallback(event => {\n    // Left mouse button only.\n    if (event.button !== 0) {\n      return;\n    }\n    onDragStart(event.target, event.pageY);\n  }, [onDragStart]);\n  const onTouchStart = useCallback(event => {\n    // Single touch only.\n    if (event.touches.length > 1) {\n      return;\n    }\n    const touch = event.changedTouches[0];\n    onDragStart(event.target, touch.pageY, touch.identifier);\n  }, [onDragStart]);\n  const onDragMove = useCallback(event => {\n    if (!dragging) {\n      return;\n    }\n    let y;\n    if (dragging.touch !== undefined) {\n      for (const touch of event.changedTouches) {\n        if (touch.identifier === dragging.touch) {\n          y = touch.pageY;\n          break;\n        }\n      }\n    } else {\n      y = event.pageY;\n    }\n    if (y === undefined) {\n      return;\n    }\n    event.preventDefault();\n    const movedY = y - dragging.dragStartY;\n    const draggedItemOffsetTop = dragging.itemTopOffset + movedY;\n    const position = getDraggedItemPosition(dragging.itemHeights, dragging.itemSpacing, draggedItemOffsetTop, dragging.initialPosition);\n    const draggedItemHeight = dragging.itemHeights[dragging.initialPosition];\n\n    // Update list items' positions.\n    itemShiftsY.current = items.map((_, j) => {\n      if (j < dragging.initialPosition) {\n        if (j >= position) {\n          return draggedItemHeight + dragging.itemSpacing;\n        } else {\n          return 0;\n        }\n      } else if (j > dragging.initialPosition) {\n        if (j <= position) {\n          return -1 * (draggedItemHeight + dragging.itemSpacing);\n        } else {\n          return 0;\n        }\n      } else {\n        return movedY;\n      }\n    });\n\n    // Apply item shifts Y.\n    let i = 0;\n    while (i < items.length) {\n      list.current.childNodes[i].style.transform = `translateY(${itemShiftsY.current[i]}px)`;\n      i++;\n    }\n    draggedItemPosition.current = {\n      previous: dragging.initialPosition,\n      new: position,\n      shiftY: getDraggedItemPositionY(dragging.itemHeights, dragging.itemSpacing, dragging.initialPosition, position) - getDraggedItemPositionY(dragging.itemHeights, dragging.itemSpacing, dragging.initialPosition, dragging.initialPosition)\n    };\n  }, [dragging]);\n  const onDragEnd = useCallback(() => {\n    setDragging();\n    setWillEndDragging(true);\n    const newItemsOrder = getNewItemsOrder(itemsOrder.current, draggedItemPosition.current.previous, draggedItemPosition.current.new);\n    setTimeout(() => {\n      setWillEndDragging(false);\n      itemsOrder.current = newItemsOrder;\n      onChange(newItemsOrder.map(i => items[i]));\n    }, animationDuration);\n  }, [itemsOrder.current]);\n  const onMouseUp = useCallback(event => {\n    if (event.which !== 1) {\n      return;\n    }\n    onDragEnd();\n  }, [onDragEnd]);\n  const onTouchEnd = useCallback(event => {\n    for (const touch of event.changedTouches) {\n      if (touch.identifier === touchId.current) {\n        onDragEnd();\n        return;\n      }\n    }\n  }, [onDragEnd]);\n  useEffect(() => {\n    if (dragging) {\n      dragMoveHandler.current = onDragMove;\n      if (dragging.touch !== undefined) {\n        touchId.current = dragging.touch;\n        window.addEventListener(\"touchmove\", dragMoveHandler.current, {\n          passive: false\n        });\n        window.addEventListener(\"touchend\", onTouchEnd);\n      } else {\n        window.addEventListener(\"mousemove\", dragMoveHandler.current, {\n          passive: false\n        });\n        window.addEventListener(\"mouseup\", onMouseUp);\n      }\n    } else {\n      if (touchId.current !== undefined) {\n        touchId.current = undefined;\n        window.removeEventListener(\"touchmove\", dragMoveHandler.current, {\n          passive: false\n        });\n        window.removeEventListener(\"touchend\", onTouchEnd);\n      } else {\n        window.removeEventListener(\"mousemove\", dragMoveHandler.current, {\n          passive: false\n        });\n        window.removeEventListener(\"mouseup\", onMouseUp);\n      }\n      dragMoveHandler.current = undefined;\n    }\n  }, [dragging]);\n  useEffect(() => {\n    if (willEndDragging) {\n      // Reset dragged item position.\n      list.current.childNodes[draggedItemPosition.current.previous].style.transform = `translateY(${draggedItemPosition.current.shiftY}px)`;\n    }\n  }, [willEndDragging]);\n  return /*#__PURE__*/_jsxDEV(Component, {\n    ...rest,\n    ref: list,\n    onTouchStart: onTouchStart,\n    onMouseDown: onMouseDown,\n    children: itemsOrder.current.map((i, position) => /*#__PURE__*/_createElement(TaskListItem, {\n      ...taskListItemProps,\n      key: i,\n      task: items[i],\n      dragging: dragging ? true : false,\n      dragged: dragging && position === draggedItemPosition.current.previous,\n      style: dragging || willEndDragging ? getItemStyle(position === draggedItemPosition.current.previous, willEndDragging, itemShiftsY.current[position], animationDuration, animationEasing) : TRANSFORM_NONE,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 222,\n        columnNumber: 9\n      }\n    }))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 220,\n    columnNumber: 5\n  }, this);\n}\n_s(SortableTaskList, \"gsaE5dYVg3eJYadhJT3KkC63l08=\");\n_c = SortableTaskList;\nSortableTaskList.propTypes = {\n  value: PropTypes.arrayOf(PropTypes.any).isRequired,\n  onChange: PropTypes.func.isRequired,\n  component: PropTypes.elementType.isRequired,\n  taskListItem: PropTypes.elementType.isRequired,\n  taskListItemProps: PropTypes.object,\n  animationDuration: PropTypes.number.isRequired,\n  animationEasing: PropTypes.string.isRequired\n};\nconst TRANSFORM_NONE = {\n  transform: \"none\"\n};\nfunction getItemStyle(isDragged, willEndDragging, shiftY, animationDuration, animationEasing) {\n  const style = {\n    // `position: relative` is for `z-index` to work.\n    position: \"relative\",\n    transition: `all ${animationDuration}ms ${animationEasing}`\n  };\n  if (isDragged) {\n    style.zIndex = 1;\n    if (!willEndDragging) {\n      style.transition = undefined;\n    }\n  } else {\n    style.transform = `translateY(${shiftY}px)`;\n  }\n  return style;\n}\nconst ListComponent = /*#__PURE__*/forwardRef(_c2 = ({\n  children,\n  ...rest\n}, ref) => /*#__PURE__*/_jsxDEV(\"div\", {\n  ref: ref,\n  ...rest,\n  children: children\n}, void 0, false, {\n  fileName: _jsxFileName,\n  lineNumber: 258,\n  columnNumber: 3\n}, this));\n_c3 = ListComponent;\nSortableTaskList.defaultProps = {\n  component: ListComponent,\n  animationDuration: 200,\n  animationEasing: \"ease-out\"\n};\n\n// Interactive elements aren't draggable.\nconst IGNORE_CLICKS_INSIDE_TAGS = [\"a\", \"button\", \"input\", \"textarea\", \"select\"];\n\n/**\n * Returns the list item that has been clicked (along with its index).\n * @param {Element} list\n * @param {Element} node — The DOM Element that has been clicked.\n * @param {string} [dragHandleDataAttribute] — Drag handle data attribute.\n * @return {any[]} [result] — An array having shape `[item, i]`.\n */\nfunction getItem(list, node, dragHandleDataAttribute) {\n  let handle;\n  let childNode;\n  while (node) {\n    if (node === list) {\n      // Clicked outside of a handle.\n      if (dragHandleDataAttribute && !handle) {\n        return;\n      }\n      if (childNode) {\n        let i = 0;\n        while (i < node.childNodes.length) {\n          if (node.childNodes[i] === childNode) {\n            return [childNode, i];\n          }\n          i++;\n        }\n      }\n      break;\n    }\n    if (IGNORE_CLICKS_INSIDE_TAGS.indexOf(node.tagName.toLowerCase()) >= 0) {\n      return;\n    }\n    if (node.dataset[dragHandleDataAttribute]) {\n      handle = node;\n    }\n    childNode = node;\n    node = node.parentElement;\n  }\n}\nfunction getDraggedItemPosition(itemHeights, itemSpacing, draggedItemOffsetTop, initialPosition) {\n  const scanLineY = draggedItemOffsetTop + itemHeights[initialPosition] / 2 + itemSpacing / 2;\n  let y = 0;\n  let i = 0;\n  let subtractOwnPosition = 0;\n  while (i < itemHeights.length) {\n    y += itemHeights[i] + itemSpacing;\n    if (scanLineY <= y) {\n      return i;\n    }\n    i++;\n  }\n  return itemHeights.length - 1;\n}\nfunction getDraggedItemPositionY(itemHeights, itemSpacing, initialPosition, position) {\n  let top = 0;\n  let j = 0;\n  while (j < position) {\n    if (j === initialPosition) {\n      position++;\n    } else {\n      top += itemHeights[j] + itemSpacing;\n    }\n    j++;\n  }\n  return top;\n}\nfunction getNewItemsOrder(itemsOrder, fromPosition, toPosition) {\n  if (toPosition < fromPosition) {\n    return itemsOrder.slice(0, toPosition).concat(itemsOrder[fromPosition]).concat(itemsOrder.slice(toPosition, fromPosition)).concat(itemsOrder.slice(fromPosition + 1));\n  }\n  if (toPosition > fromPosition) {\n    return itemsOrder.slice(0, fromPosition).concat(itemsOrder.slice(fromPosition + 1, toPosition + 1)).concat(itemsOrder[fromPosition]).concat(itemsOrder.slice(toPosition + 1));\n  }\n  return itemsOrder.slice();\n}\nexport default SortableTaskList;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"SortableTaskList\");\n$RefreshReg$(_c2, \"ListComponent$forwardRef\");\n$RefreshReg$(_c3, \"ListComponent\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","forwardRef","PropTypes","createElement","_createElement","jsxDEV","_jsxDEV","SortableTaskList","value","items","onChange","component","Component","taskListItem","TaskListItem","taskListItemProps","dragHandleDataAttribute","animationDuration","animationEasing","rest","_s","list","dragging","setDragging","willEndDragging","setWillEndDragging","touchId","dragMoveHandler","draggedItemPosition","itemShiftsY","itemsOrder","prevItems","current","map","item","i","onDragStart","node","y","touch","length","getItem","itemNode","position","initialPosition","itemHeights","Array","prototype","call","childNodes","getBoundingClientRect","height","itemSpacing","top","bottom","itemTopOffset","dragStartY","previous","new","shiftY","_","onMouseDown","event","button","target","pageY","onTouchStart","touches","changedTouches","identifier","onDragMove","undefined","preventDefault","movedY","draggedItemOffsetTop","getDraggedItemPosition","draggedItemHeight","j","style","transform","getDraggedItemPositionY","onDragEnd","newItemsOrder","getNewItemsOrder","setTimeout","onMouseUp","which","onTouchEnd","window","addEventListener","passive","removeEventListener","ref","children","key","task","dragged","getItemStyle","TRANSFORM_NONE","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","_c","propTypes","arrayOf","any","isRequired","func","elementType","object","number","string","isDragged","transition","zIndex","ListComponent","_c2","_c3","defaultProps","IGNORE_CLICKS_INSIDE_TAGS","handle","childNode","indexOf","tagName","toLowerCase","dataset","parentElement","scanLineY","subtractOwnPosition","fromPosition","toPosition","slice","concat","$RefreshReg$"],"sources":["/Users/dini/Desktop/productivity-workspace/frontend/src/components/SortableTaskList.jsx"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef, forwardRef } from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"./css/TaskList.css\";\n\n/**\n * Demo:\n * https://codepen.io/catamphetamine/pen/qBWxEQX\n *\n * `TaskListItem` receives properties:\n * `dragging: boolean` — Is `true` when some item is being dragged.\n * `dragged: boolean` — Is `true` when this item is being dragged.\n * `style: object` — The `style` that must be set on the item root element.\n */\nfunction SortableTaskList({ value: items, onChange, component: Component, taskListItem: TaskListItem, taskListItemProps, dragHandleDataAttribute, animationDuration, animationEasing, ...rest }) {\n  const list = useRef();\n  const [dragging, setDragging] = useState();\n  const [willEndDragging, setWillEndDragging] = useState();\n  const touchId = useRef();\n  const dragMoveHandler = useRef();\n  const draggedItemPosition = useRef();\n  const itemShiftsY = useRef();\n\n  const itemsOrder = useRef();\n  const prevItems = useRef();\n  if (items !== prevItems.current) {\n    prevItems.current = items;\n    // Reset items order.\n    itemsOrder.current = items.map((item, i) => i);\n  }\n\n  const onDragStart = useCallback(\n    (node, y, touch) => {\n      if (dragging) {\n        return;\n      }\n      // The list requires at least two items in order to be sortable.\n      if (items.length === 1) {\n        return;\n      }\n      const item = getItem(list.current, node, dragHandleDataAttribute);\n      if (!item) {\n        return;\n      }\n      const [itemNode, position] = item;\n      setDragging({\n        touch,\n        initialPosition: position,\n        // Using `.getBoundingClientRect()` instead of `.offsetHeight`/`.offsetTop`\n        // because `.offsetXxx` values don't know how to work with fractional pixels.\n        // Fractional pixels (for example, `0.5`) are used on \"retina\" screens.\n        itemHeights: Array.prototype.map.call(list.current.childNodes, node => node.getBoundingClientRect().height),\n        itemSpacing: list.current.childNodes[1].getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().bottom,\n        itemTopOffset: itemNode.getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().top,\n        dragStartY: y\n      });\n      draggedItemPosition.current = {\n        previous: position,\n        new: position,\n        shiftY: 0\n      };\n      itemShiftsY.current = items.map(_ => 0);\n    },\n    [dragging]\n  );\n\n  const onMouseDown = useCallback(\n    event => {\n      // Left mouse button only.\n      if (event.button !== 0) {\n        return;\n      }\n      onDragStart(event.target, event.pageY);\n    },\n    [onDragStart]\n  );\n\n  const onTouchStart = useCallback(\n    event => {\n      // Single touch only.\n      if (event.touches.length > 1) {\n        return;\n      }\n      const touch = event.changedTouches[0];\n      onDragStart(event.target, touch.pageY, touch.identifier);\n    },\n    [onDragStart]\n  );\n\n  const onDragMove = useCallback(\n    event => {\n      if (!dragging) {\n        return;\n      }\n\n      let y;\n      if (dragging.touch !== undefined) {\n        for (const touch of event.changedTouches) {\n          if (touch.identifier === dragging.touch) {\n            y = touch.pageY;\n            break;\n          }\n        }\n      } else {\n        y = event.pageY;\n      }\n\n      if (y === undefined) {\n        return;\n      }\n\n      event.preventDefault();\n\n      const movedY = y - dragging.dragStartY;\n      const draggedItemOffsetTop = dragging.itemTopOffset + movedY;\n\n      const position = getDraggedItemPosition(dragging.itemHeights, dragging.itemSpacing, draggedItemOffsetTop, dragging.initialPosition);\n\n      const draggedItemHeight = dragging.itemHeights[dragging.initialPosition];\n\n      // Update list items' positions.\n      itemShiftsY.current = items.map((_, j) => {\n        if (j < dragging.initialPosition) {\n          if (j >= position) {\n            return draggedItemHeight + dragging.itemSpacing;\n          } else {\n            return 0;\n          }\n        } else if (j > dragging.initialPosition) {\n          if (j <= position) {\n            return -1 * (draggedItemHeight + dragging.itemSpacing);\n          } else {\n            return 0;\n          }\n        } else {\n          return movedY;\n        }\n      });\n\n      // Apply item shifts Y.\n      let i = 0;\n      while (i < items.length) {\n        list.current.childNodes[i].style.transform = `translateY(${itemShiftsY.current[i]}px)`;\n        i++;\n      }\n\n      draggedItemPosition.current = {\n        previous: dragging.initialPosition,\n        new: position,\n        shiftY: getDraggedItemPositionY(dragging.itemHeights, dragging.itemSpacing, dragging.initialPosition, position) - getDraggedItemPositionY(dragging.itemHeights, dragging.itemSpacing, dragging.initialPosition, dragging.initialPosition)\n      };\n    },\n    [dragging]\n  );\n\n  const onDragEnd = useCallback(() => {\n    setDragging();\n    setWillEndDragging(true);\n    const newItemsOrder = getNewItemsOrder(itemsOrder.current, draggedItemPosition.current.previous, draggedItemPosition.current.new);\n    setTimeout(() => {\n      setWillEndDragging(false);\n      itemsOrder.current = newItemsOrder;\n      onChange(newItemsOrder.map(i => items[i]));\n    }, animationDuration);\n  }, [itemsOrder.current]);\n\n  const onMouseUp = useCallback(\n    event => {\n      if (event.which !== 1) {\n        return;\n      }\n      onDragEnd();\n    },\n    [onDragEnd]\n  );\n\n  const onTouchEnd = useCallback(\n    event => {\n      for (const touch of event.changedTouches) {\n        if (touch.identifier === touchId.current) {\n          onDragEnd();\n          return;\n        }\n      }\n    },\n    [onDragEnd]\n  );\n\n  useEffect(() => {\n    if (dragging) {\n      dragMoveHandler.current = onDragMove;\n      if (dragging.touch !== undefined) {\n        touchId.current = dragging.touch;\n        window.addEventListener(\"touchmove\", dragMoveHandler.current, { passive: false });\n        window.addEventListener(\"touchend\", onTouchEnd);\n      } else {\n        window.addEventListener(\"mousemove\", dragMoveHandler.current, { passive: false });\n        window.addEventListener(\"mouseup\", onMouseUp);\n      }\n    } else {\n      if (touchId.current !== undefined) {\n        touchId.current = undefined;\n        window.removeEventListener(\"touchmove\", dragMoveHandler.current, { passive: false });\n        window.removeEventListener(\"touchend\", onTouchEnd);\n      } else {\n        window.removeEventListener(\"mousemove\", dragMoveHandler.current, { passive: false });\n        window.removeEventListener(\"mouseup\", onMouseUp);\n      }\n      dragMoveHandler.current = undefined;\n    }\n  }, [dragging]);\n\n  useEffect(() => {\n    if (willEndDragging) {\n      // Reset dragged item position.\n      list.current.childNodes[draggedItemPosition.current.previous].style.transform = `translateY(${draggedItemPosition.current.shiftY}px)`;\n    }\n  }, [willEndDragging]);\n\n  return (\n    <Component {...rest} ref={list} onTouchStart={onTouchStart} onMouseDown={onMouseDown}>\n      {itemsOrder.current.map((i, position) => (\n        <TaskListItem {...taskListItemProps} key={i} task={items[i]} dragging={dragging ? true : false} dragged={dragging && position === draggedItemPosition.current.previous} style={dragging || willEndDragging ? getItemStyle(position === draggedItemPosition.current.previous, willEndDragging, itemShiftsY.current[position], animationDuration, animationEasing) : TRANSFORM_NONE} />\n      ))}\n    </Component>\n  );\n}\n\nSortableTaskList.propTypes = {\n  value: PropTypes.arrayOf(PropTypes.any).isRequired,\n  onChange: PropTypes.func.isRequired,\n  component: PropTypes.elementType.isRequired,\n  taskListItem: PropTypes.elementType.isRequired,\n  taskListItemProps: PropTypes.object,\n  animationDuration: PropTypes.number.isRequired,\n  animationEasing: PropTypes.string.isRequired\n};\n\nconst TRANSFORM_NONE = { transform: \"none\" };\n\nfunction getItemStyle(isDragged, willEndDragging, shiftY, animationDuration, animationEasing) {\n  const style = {\n    // `position: relative` is for `z-index` to work.\n    position: \"relative\",\n    transition: `all ${animationDuration}ms ${animationEasing}`\n  };\n  if (isDragged) {\n    style.zIndex = 1;\n    if (!willEndDragging) {\n      style.transition = undefined;\n    }\n  } else {\n    style.transform = `translateY(${shiftY}px)`;\n  }\n  return style;\n}\n\nconst ListComponent = forwardRef(({ children, ...rest }, ref) => (\n  <div ref={ref} {...rest}>\n    {children}\n  </div>\n));\n\nSortableTaskList.defaultProps = {\n  component: ListComponent,\n  animationDuration: 200,\n  animationEasing: \"ease-out\"\n};\n\n// Interactive elements aren't draggable.\nconst IGNORE_CLICKS_INSIDE_TAGS = [\"a\", \"button\", \"input\", \"textarea\", \"select\"];\n\n/**\n * Returns the list item that has been clicked (along with its index).\n * @param {Element} list\n * @param {Element} node — The DOM Element that has been clicked.\n * @param {string} [dragHandleDataAttribute] — Drag handle data attribute.\n * @return {any[]} [result] — An array having shape `[item, i]`.\n */\nfunction getItem(list, node, dragHandleDataAttribute) {\n  let handle;\n  let childNode;\n  while (node) {\n    if (node === list) {\n      // Clicked outside of a handle.\n      if (dragHandleDataAttribute && !handle) {\n        return;\n      }\n      if (childNode) {\n        let i = 0;\n        while (i < node.childNodes.length) {\n          if (node.childNodes[i] === childNode) {\n            return [childNode, i];\n          }\n          i++;\n        }\n      }\n      break;\n    }\n    if (IGNORE_CLICKS_INSIDE_TAGS.indexOf(node.tagName.toLowerCase()) >= 0) {\n      return;\n    }\n    if (node.dataset[dragHandleDataAttribute]) {\n      handle = node;\n    }\n    childNode = node;\n    node = node.parentElement;\n  }\n}\n\nfunction getDraggedItemPosition(itemHeights, itemSpacing, draggedItemOffsetTop, initialPosition) {\n  const scanLineY = draggedItemOffsetTop + itemHeights[initialPosition] / 2 + itemSpacing / 2;\n  let y = 0;\n  let i = 0;\n  let subtractOwnPosition = 0;\n  while (i < itemHeights.length) {\n    y += itemHeights[i] + itemSpacing;\n    if (scanLineY <= y) {\n      return i;\n    }\n    i++;\n  }\n  return itemHeights.length - 1;\n}\n\nfunction getDraggedItemPositionY(itemHeights, itemSpacing, initialPosition, position) {\n  let top = 0;\n  let j = 0;\n  while (j < position) {\n    if (j === initialPosition) {\n      position++;\n    } else {\n      top += itemHeights[j] + itemSpacing;\n    }\n    j++;\n  }\n  return top;\n}\n\nfunction getNewItemsOrder(itemsOrder, fromPosition, toPosition) {\n  if (toPosition < fromPosition) {\n    return itemsOrder\n      .slice(0, toPosition)\n      .concat(itemsOrder[fromPosition])\n      .concat(itemsOrder.slice(toPosition, fromPosition))\n      .concat(itemsOrder.slice(fromPosition + 1));\n  }\n  if (toPosition > fromPosition) {\n    return itemsOrder\n      .slice(0, fromPosition)\n      .concat(itemsOrder.slice(fromPosition + 1, toPosition + 1))\n      .concat(itemsOrder[fromPosition])\n      .concat(itemsOrder.slice(toPosition + 1));\n  }\n  return itemsOrder.slice();\n}\n\nexport default SortableTaskList;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}