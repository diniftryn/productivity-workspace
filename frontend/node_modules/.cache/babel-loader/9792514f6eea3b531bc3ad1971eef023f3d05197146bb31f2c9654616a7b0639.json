{"ast":null,"code":"import React,{useState,useEffect,useCallback,useRef,forwardRef}from\"react\";import\"../css/TaskList.css\";/**\n * Demo:\n * https://codepen.io/catamphetamine/pen/qBWxEQX\n *\n * `TaskListItem` receives properties:\n * `dragging: boolean` — Is `true` when some item is being dragged.\n * `dragged: boolean` — Is `true` when this item is being dragged.\n * `style: object` — The `style` that must be set on the item root element.\n */import{createElement as _createElement}from\"react\";import{jsx as _jsx}from\"react/jsx-runtime\";function SortableTaskList(_ref){let{value:items,onChange,component:Component,taskListItem:TaskListItem,taskListItemProps,dragHandleDataAttribute,animationDuration,animationEasing,...rest}=_ref;const list=useRef();const[dragging,setDragging]=useState();const[willEndDragging,setWillEndDragging]=useState();const touchId=useRef();const dragMoveHandler=useRef();const draggedItemPosition=useRef();const itemShiftsY=useRef();const itemsOrder=useRef();const prevItems=useRef();if(items!==prevItems.current){prevItems.current=items;// Reset items order.\nitemsOrder.current=items.map((item,i)=>i);}const onDragStart=useCallback((node,y,touch)=>{if(dragging){return;}// The list requires at least two items in order to be sortable.\nif(items.length===1){return;}const item=getItem(list.current,node,dragHandleDataAttribute);if(!item){return;}const[itemNode,position]=item;setDragging({touch,initialPosition:position,// Using `.getBoundingClientRect()` instead of `.offsetHeight`/`.offsetTop`\n// because `.offsetXxx` values don't know how to work with fractional pixels.\n// Fractional pixels (for example, `0.5`) are used on \"retina\" screens.\nitemHeights:Array.prototype.map.call(list.current.childNodes,node=>node.getBoundingClientRect().height),itemSpacing:list.current.childNodes[1].getBoundingClientRect().top-list.current.childNodes[0].getBoundingClientRect().bottom,itemTopOffset:itemNode.getBoundingClientRect().top-list.current.childNodes[0].getBoundingClientRect().top,dragStartY:y});draggedItemPosition.current={previous:position,new:position,shiftY:0};itemShiftsY.current=items.map(_=>0);},[dragging]);const onMouseDown=useCallback(event=>{// Left mouse button only.\nif(event.button!==0){return;}onDragStart(event.target,event.pageY);},[onDragStart]);const onTouchStart=useCallback(event=>{// Single touch only.\nif(event.touches.length>1){return;}const touch=event.changedTouches[0];onDragStart(event.target,touch.pageY,touch.identifier);},[onDragStart]);const onDragMove=useCallback(event=>{if(!dragging){return;}let y;if(dragging.touch!==undefined){for(const touch of event.changedTouches){if(touch.identifier===dragging.touch){y=touch.pageY;break;}}}else{y=event.pageY;}if(y===undefined){return;}event.preventDefault();const movedY=y-dragging.dragStartY;const draggedItemOffsetTop=dragging.itemTopOffset+movedY;const position=getDraggedItemPosition(dragging.itemHeights,dragging.itemSpacing,draggedItemOffsetTop,dragging.initialPosition);const draggedItemHeight=dragging.itemHeights[dragging.initialPosition];// Update list items' positions.\nitemShiftsY.current=items.map((_,j)=>{if(j<dragging.initialPosition){if(j>=position){return draggedItemHeight+dragging.itemSpacing;}else{return 0;}}else if(j>dragging.initialPosition){if(j<=position){return-1*(draggedItemHeight+dragging.itemSpacing);}else{return 0;}}else{return movedY;}});// Apply item shifts Y.\nlet i=0;while(i<items.length){list.current.childNodes[i].style.transform=\"translateY(\".concat(itemShiftsY.current[i],\"px)\");i++;}draggedItemPosition.current={previous:dragging.initialPosition,new:position,shiftY:getDraggedItemPositionY(dragging.itemHeights,dragging.itemSpacing,dragging.initialPosition,position)-getDraggedItemPositionY(dragging.itemHeights,dragging.itemSpacing,dragging.initialPosition,dragging.initialPosition)};},[dragging]);const onDragEnd=useCallback(()=>{setDragging();setWillEndDragging(true);const newItemsOrder=getNewItemsOrder(itemsOrder.current,draggedItemPosition.current.previous,draggedItemPosition.current.new);setTimeout(()=>{setWillEndDragging(false);itemsOrder.current=newItemsOrder;onChange(newItemsOrder.map(i=>items[i]));},animationDuration);},[itemsOrder.current]);const onMouseUp=useCallback(event=>{if(event.which!==1){return;}onDragEnd();},[onDragEnd]);const onTouchEnd=useCallback(event=>{for(const touch of event.changedTouches){if(touch.identifier===touchId.current){onDragEnd();return;}}},[onDragEnd]);useEffect(()=>{if(dragging){dragMoveHandler.current=onDragMove;if(dragging.touch!==undefined){touchId.current=dragging.touch;window.addEventListener(\"touchmove\",dragMoveHandler.current,{passive:false});window.addEventListener(\"touchend\",onTouchEnd);}else{window.addEventListener(\"mousemove\",dragMoveHandler.current,{passive:false});window.addEventListener(\"mouseup\",onMouseUp);}}else{if(touchId.current!==undefined){touchId.current=undefined;window.removeEventListener(\"touchmove\",dragMoveHandler.current,{passive:false});window.removeEventListener(\"touchend\",onTouchEnd);}else{window.removeEventListener(\"mousemove\",dragMoveHandler.current,{passive:false});window.removeEventListener(\"mouseup\",onMouseUp);}dragMoveHandler.current=undefined;}},[dragging]);useEffect(()=>{if(willEndDragging){// Reset dragged item position.\nlist.current.childNodes[draggedItemPosition.current.previous].style.transform=\"translateY(\".concat(draggedItemPosition.current.shiftY,\"px)\");}},[willEndDragging]);return/*#__PURE__*/_jsx(Component,{...rest,ref:list,onTouchStart:onTouchStart,onMouseDown:onMouseDown,children:itemsOrder.current.map((i,position)=>/*#__PURE__*/_createElement(TaskListItem,{...taskListItemProps,key:i,task:items[i],dragging:dragging?true:false,dragged:dragging&&position===draggedItemPosition.current.previous,style:dragging||willEndDragging?getItemStyle(position===draggedItemPosition.current.previous,willEndDragging,itemShiftsY.current[position],animationDuration,animationEasing):TRANSFORM_NONE}))});}const TRANSFORM_NONE={transform:\"none\"};function getItemStyle(isDragged,willEndDragging,shiftY,animationDuration,animationEasing){const style={// `position: relative` is for `z-index` to work.\nposition:\"relative\",transition:\"all \".concat(animationDuration,\"ms \").concat(animationEasing)};if(isDragged){style.zIndex=1;if(!willEndDragging){style.transition=undefined;}}else{style.transform=\"translateY(\".concat(shiftY,\"px)\");}return style;}const ListComponent=/*#__PURE__*/forwardRef((_ref2,ref)=>{let{children,...rest}=_ref2;return/*#__PURE__*/_jsx(\"div\",{ref:ref,...rest,children:children});});SortableTaskList.defaultProps={component:ListComponent,animationDuration:200,animationEasing:\"ease-out\"};// Interactive elements aren't draggable.\nconst IGNORE_CLICKS_INSIDE_TAGS=[\"a\",\"button\",\"input\",\"textarea\",\"select\"];/**\n * Returns the list item that has been clicked (along with its index).\n * @param {Element} list\n * @param {Element} node — The DOM Element that has been clicked.\n * @param {string} [dragHandleDataAttribute] — Drag handle data attribute.\n * @return {any[]} [result] — An array having shape `[item, i]`.\n */function getItem(list,node,dragHandleDataAttribute){let handle;let childNode;while(node){if(node===list){// Clicked outside of a handle.\nif(dragHandleDataAttribute&&!handle){return;}if(childNode){let i=0;while(i<node.childNodes.length){if(node.childNodes[i]===childNode){return[childNode,i];}i++;}}break;}if(IGNORE_CLICKS_INSIDE_TAGS.indexOf(node.tagName.toLowerCase())>=0){return;}if(node.dataset[dragHandleDataAttribute]){handle=node;}childNode=node;node=node.parentElement;}}function getDraggedItemPosition(itemHeights,itemSpacing,draggedItemOffsetTop,initialPosition){const scanLineY=draggedItemOffsetTop+itemHeights[initialPosition]/2+itemSpacing/2;let y=0;let i=0;let subtractOwnPosition=0;while(i<itemHeights.length){y+=itemHeights[i]+itemSpacing;if(scanLineY<=y){return i;}i++;}return itemHeights.length-1;}function getDraggedItemPositionY(itemHeights,itemSpacing,initialPosition,position){let top=0;let j=0;while(j<position){if(j===initialPosition){position++;}else{top+=itemHeights[j]+itemSpacing;}j++;}return top;}function getNewItemsOrder(itemsOrder,fromPosition,toPosition){if(toPosition<fromPosition){return itemsOrder.slice(0,toPosition).concat(itemsOrder[fromPosition]).concat(itemsOrder.slice(toPosition,fromPosition)).concat(itemsOrder.slice(fromPosition+1));}if(toPosition>fromPosition){return itemsOrder.slice(0,fromPosition).concat(itemsOrder.slice(fromPosition+1,toPosition+1)).concat(itemsOrder[fromPosition]).concat(itemsOrder.slice(toPosition+1));}return itemsOrder.slice();}export default SortableTaskList;","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","forwardRef","createElement","_createElement","jsx","_jsx","SortableTaskList","_ref","value","items","onChange","component","Component","taskListItem","TaskListItem","taskListItemProps","dragHandleDataAttribute","animationDuration","animationEasing","rest","list","dragging","setDragging","willEndDragging","setWillEndDragging","touchId","dragMoveHandler","draggedItemPosition","itemShiftsY","itemsOrder","prevItems","current","map","item","i","onDragStart","node","y","touch","length","getItem","itemNode","position","initialPosition","itemHeights","Array","prototype","call","childNodes","getBoundingClientRect","height","itemSpacing","top","bottom","itemTopOffset","dragStartY","previous","new","shiftY","_","onMouseDown","event","button","target","pageY","onTouchStart","touches","changedTouches","identifier","onDragMove","undefined","preventDefault","movedY","draggedItemOffsetTop","getDraggedItemPosition","draggedItemHeight","j","style","transform","concat","getDraggedItemPositionY","onDragEnd","newItemsOrder","getNewItemsOrder","setTimeout","onMouseUp","which","onTouchEnd","window","addEventListener","passive","removeEventListener","ref","children","key","task","dragged","getItemStyle","TRANSFORM_NONE","isDragged","transition","zIndex","ListComponent","_ref2","defaultProps","IGNORE_CLICKS_INSIDE_TAGS","handle","childNode","indexOf","tagName","toLowerCase","dataset","parentElement","scanLineY","subtractOwnPosition","fromPosition","toPosition","slice"],"sources":["/Users/dini/Desktop/productivity-workspace/frontend/src/components/SortableTaskList.js"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef, forwardRef } from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"../css/TaskList.css\";\n\n/**\n * Demo:\n * https://codepen.io/catamphetamine/pen/qBWxEQX\n *\n * `TaskListItem` receives properties:\n * `dragging: boolean` — Is `true` when some item is being dragged.\n * `dragged: boolean` — Is `true` when this item is being dragged.\n * `style: object` — The `style` that must be set on the item root element.\n */\nfunction SortableTaskList({ value: items, onChange, component: Component, taskListItem: TaskListItem, taskListItemProps, dragHandleDataAttribute, animationDuration, animationEasing, ...rest }) {\n  const list = useRef();\n  const [dragging, setDragging] = useState();\n  const [willEndDragging, setWillEndDragging] = useState();\n  const touchId = useRef();\n  const dragMoveHandler = useRef();\n  const draggedItemPosition = useRef();\n  const itemShiftsY = useRef();\n\n  const itemsOrder = useRef();\n  const prevItems = useRef();\n  if (items !== prevItems.current) {\n    prevItems.current = items;\n    // Reset items order.\n    itemsOrder.current = items.map((item, i) => i);\n  }\n\n  const onDragStart = useCallback(\n    (node, y, touch) => {\n      if (dragging) {\n        return;\n      }\n      // The list requires at least two items in order to be sortable.\n      if (items.length === 1) {\n        return;\n      }\n      const item = getItem(list.current, node, dragHandleDataAttribute);\n      if (!item) {\n        return;\n      }\n      const [itemNode, position] = item;\n      setDragging({\n        touch,\n        initialPosition: position,\n        // Using `.getBoundingClientRect()` instead of `.offsetHeight`/`.offsetTop`\n        // because `.offsetXxx` values don't know how to work with fractional pixels.\n        // Fractional pixels (for example, `0.5`) are used on \"retina\" screens.\n        itemHeights: Array.prototype.map.call(list.current.childNodes, node => node.getBoundingClientRect().height),\n        itemSpacing: list.current.childNodes[1].getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().bottom,\n        itemTopOffset: itemNode.getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().top,\n        dragStartY: y\n      });\n      draggedItemPosition.current = {\n        previous: position,\n        new: position,\n        shiftY: 0\n      };\n      itemShiftsY.current = items.map(_ => 0);\n    },\n    [dragging]\n  );\n\n  const onMouseDown = useCallback(\n    event => {\n      // Left mouse button only.\n      if (event.button !== 0) {\n        return;\n      }\n      onDragStart(event.target, event.pageY);\n    },\n    [onDragStart]\n  );\n\n  const onTouchStart = useCallback(\n    event => {\n      // Single touch only.\n      if (event.touches.length > 1) {\n        return;\n      }\n      const touch = event.changedTouches[0];\n      onDragStart(event.target, touch.pageY, touch.identifier);\n    },\n    [onDragStart]\n  );\n\n  const onDragMove = useCallback(\n    event => {\n      if (!dragging) {\n        return;\n      }\n\n      let y;\n      if (dragging.touch !== undefined) {\n        for (const touch of event.changedTouches) {\n          if (touch.identifier === dragging.touch) {\n            y = touch.pageY;\n            break;\n          }\n        }\n      } else {\n        y = event.pageY;\n      }\n\n      if (y === undefined) {\n        return;\n      }\n\n      event.preventDefault();\n\n      const movedY = y - dragging.dragStartY;\n      const draggedItemOffsetTop = dragging.itemTopOffset + movedY;\n\n      const position = getDraggedItemPosition(dragging.itemHeights, dragging.itemSpacing, draggedItemOffsetTop, dragging.initialPosition);\n\n      const draggedItemHeight = dragging.itemHeights[dragging.initialPosition];\n\n      // Update list items' positions.\n      itemShiftsY.current = items.map((_, j) => {\n        if (j < dragging.initialPosition) {\n          if (j >= position) {\n            return draggedItemHeight + dragging.itemSpacing;\n          } else {\n            return 0;\n          }\n        } else if (j > dragging.initialPosition) {\n          if (j <= position) {\n            return -1 * (draggedItemHeight + dragging.itemSpacing);\n          } else {\n            return 0;\n          }\n        } else {\n          return movedY;\n        }\n      });\n\n      // Apply item shifts Y.\n      let i = 0;\n      while (i < items.length) {\n        list.current.childNodes[i].style.transform = `translateY(${itemShiftsY.current[i]}px)`;\n        i++;\n      }\n\n      draggedItemPosition.current = {\n        previous: dragging.initialPosition,\n        new: position,\n        shiftY: getDraggedItemPositionY(dragging.itemHeights, dragging.itemSpacing, dragging.initialPosition, position) - getDraggedItemPositionY(dragging.itemHeights, dragging.itemSpacing, dragging.initialPosition, dragging.initialPosition)\n      };\n    },\n    [dragging]\n  );\n\n  const onDragEnd = useCallback(() => {\n    setDragging();\n    setWillEndDragging(true);\n    const newItemsOrder = getNewItemsOrder(itemsOrder.current, draggedItemPosition.current.previous, draggedItemPosition.current.new);\n    setTimeout(() => {\n      setWillEndDragging(false);\n      itemsOrder.current = newItemsOrder;\n      onChange(newItemsOrder.map(i => items[i]));\n    }, animationDuration);\n  }, [itemsOrder.current]);\n\n  const onMouseUp = useCallback(\n    event => {\n      if (event.which !== 1) {\n        return;\n      }\n      onDragEnd();\n    },\n    [onDragEnd]\n  );\n\n  const onTouchEnd = useCallback(\n    event => {\n      for (const touch of event.changedTouches) {\n        if (touch.identifier === touchId.current) {\n          onDragEnd();\n          return;\n        }\n      }\n    },\n    [onDragEnd]\n  );\n\n  useEffect(() => {\n    if (dragging) {\n      dragMoveHandler.current = onDragMove;\n      if (dragging.touch !== undefined) {\n        touchId.current = dragging.touch;\n        window.addEventListener(\"touchmove\", dragMoveHandler.current, { passive: false });\n        window.addEventListener(\"touchend\", onTouchEnd);\n      } else {\n        window.addEventListener(\"mousemove\", dragMoveHandler.current, { passive: false });\n        window.addEventListener(\"mouseup\", onMouseUp);\n      }\n    } else {\n      if (touchId.current !== undefined) {\n        touchId.current = undefined;\n        window.removeEventListener(\"touchmove\", dragMoveHandler.current, { passive: false });\n        window.removeEventListener(\"touchend\", onTouchEnd);\n      } else {\n        window.removeEventListener(\"mousemove\", dragMoveHandler.current, { passive: false });\n        window.removeEventListener(\"mouseup\", onMouseUp);\n      }\n      dragMoveHandler.current = undefined;\n    }\n  }, [dragging]);\n\n  useEffect(() => {\n    if (willEndDragging) {\n      // Reset dragged item position.\n      list.current.childNodes[draggedItemPosition.current.previous].style.transform = `translateY(${draggedItemPosition.current.shiftY}px)`;\n    }\n  }, [willEndDragging]);\n\n  return (\n    <Component {...rest} ref={list} onTouchStart={onTouchStart} onMouseDown={onMouseDown}>\n      {itemsOrder.current.map((i, position) => (\n        <TaskListItem {...taskListItemProps} key={i} task={items[i]} dragging={dragging ? true : false} dragged={dragging && position === draggedItemPosition.current.previous} style={dragging || willEndDragging ? getItemStyle(position === draggedItemPosition.current.previous, willEndDragging, itemShiftsY.current[position], animationDuration, animationEasing) : TRANSFORM_NONE} />\n      ))}\n    </Component>\n  );\n}\n\nSortableTaskList.propTypes = {\n  value: PropTypes.arrayOf(PropTypes.any).isRequired,\n  onChange: PropTypes.func.isRequired,\n  component: PropTypes.elementType.isRequired,\n  taskListItem: PropTypes.elementType.isRequired,\n  taskListItemProps: PropTypes.object,\n  animationDuration: PropTypes.number.isRequired,\n  animationEasing: PropTypes.string.isRequired\n};\n\nconst TRANSFORM_NONE = { transform: \"none\" };\n\nfunction getItemStyle(isDragged, willEndDragging, shiftY, animationDuration, animationEasing) {\n  const style = {\n    // `position: relative` is for `z-index` to work.\n    position: \"relative\",\n    transition: `all ${animationDuration}ms ${animationEasing}`\n  };\n  if (isDragged) {\n    style.zIndex = 1;\n    if (!willEndDragging) {\n      style.transition = undefined;\n    }\n  } else {\n    style.transform = `translateY(${shiftY}px)`;\n  }\n  return style;\n}\n\nconst ListComponent = forwardRef(({ children, ...rest }, ref) => (\n  <div ref={ref} {...rest}>\n    {children}\n  </div>\n));\n\nSortableTaskList.defaultProps = {\n  component: ListComponent,\n  animationDuration: 200,\n  animationEasing: \"ease-out\"\n};\n\n// Interactive elements aren't draggable.\nconst IGNORE_CLICKS_INSIDE_TAGS = [\"a\", \"button\", \"input\", \"textarea\", \"select\"];\n\n/**\n * Returns the list item that has been clicked (along with its index).\n * @param {Element} list\n * @param {Element} node — The DOM Element that has been clicked.\n * @param {string} [dragHandleDataAttribute] — Drag handle data attribute.\n * @return {any[]} [result] — An array having shape `[item, i]`.\n */\nfunction getItem(list, node, dragHandleDataAttribute) {\n  let handle;\n  let childNode;\n  while (node) {\n    if (node === list) {\n      // Clicked outside of a handle.\n      if (dragHandleDataAttribute && !handle) {\n        return;\n      }\n      if (childNode) {\n        let i = 0;\n        while (i < node.childNodes.length) {\n          if (node.childNodes[i] === childNode) {\n            return [childNode, i];\n          }\n          i++;\n        }\n      }\n      break;\n    }\n    if (IGNORE_CLICKS_INSIDE_TAGS.indexOf(node.tagName.toLowerCase()) >= 0) {\n      return;\n    }\n    if (node.dataset[dragHandleDataAttribute]) {\n      handle = node;\n    }\n    childNode = node;\n    node = node.parentElement;\n  }\n}\n\nfunction getDraggedItemPosition(itemHeights, itemSpacing, draggedItemOffsetTop, initialPosition) {\n  const scanLineY = draggedItemOffsetTop + itemHeights[initialPosition] / 2 + itemSpacing / 2;\n  let y = 0;\n  let i = 0;\n  let subtractOwnPosition = 0;\n  while (i < itemHeights.length) {\n    y += itemHeights[i] + itemSpacing;\n    if (scanLineY <= y) {\n      return i;\n    }\n    i++;\n  }\n  return itemHeights.length - 1;\n}\n\nfunction getDraggedItemPositionY(itemHeights, itemSpacing, initialPosition, position) {\n  let top = 0;\n  let j = 0;\n  while (j < position) {\n    if (j === initialPosition) {\n      position++;\n    } else {\n      top += itemHeights[j] + itemSpacing;\n    }\n    j++;\n  }\n  return top;\n}\n\nfunction getNewItemsOrder(itemsOrder, fromPosition, toPosition) {\n  if (toPosition < fromPosition) {\n    return itemsOrder\n      .slice(0, toPosition)\n      .concat(itemsOrder[fromPosition])\n      .concat(itemsOrder.slice(toPosition, fromPosition))\n      .concat(itemsOrder.slice(fromPosition + 1));\n  }\n  if (toPosition > fromPosition) {\n    return itemsOrder\n      .slice(0, fromPosition)\n      .concat(itemsOrder.slice(fromPosition + 1, toPosition + 1))\n      .concat(itemsOrder[fromPosition])\n      .concat(itemsOrder.slice(toPosition + 1));\n  }\n  return itemsOrder.slice();\n}\n\nexport default SortableTaskList;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}